//! Methods for retrieving swagger-related information from an HTTP request.
use hyper::Request;

/// A macro for joining together two or more RequestParsers to create a struct that implements
/// RequestParser with a function parse_operation_id that matches hyper requests against the different
/// RequestParsers in turn until it gets a match (or returns an error if none match)
///
/// The order in which the request parsers are passed to the macro specifies the order in which the request
/// is tested against them. If there is any possibility of two RequestParsers matching the same request
/// this should not be used.
#[macro_export]
macro_rules! request_parser_joiner {
    ($name:ident ,$($T:ty), *) => {
        struct $name;

        impl <B> RequestParser<B> for $name
            where $($T: RequestParser<B>, )*
        {
            fn parse_operation_id(request: &Request<B>) -> Option<&'static str> {
                __impl_request_parser_joiner!(request, $($T), *)
            }
        }
    };
}

/// This macro should only be used by the request_parser_joiner macro
#[macro_export]
#[doc(hidden)]
macro_rules! __impl_request_parser_joiner {
    ($argname:expr, $head:ty) => {<$head as RequestParser<B>>::parse_operation_id(&$argname)};
    ($argname:expr, $head:ty, $( $tail:ty), *) => {
        match <$head as RequestParser<B>>::parse_operation_id(&$argname) {
                Some(s) => Some(s),
                None => __impl_request_parser_joiner!($argname, $( $tail), *),
        }
    };
}

/// A trait for retrieving swagger-related information from a request.
///
/// This allows other middlewares to retrieve API-related information from a request that
/// may not have been handled by the autogenerated API code yet.   For example, a statistics
/// tracking service may wish to use this to count requests per-operation.
///
/// The trait is automatically implemented by swagger-codegen.
pub trait RequestParser<B> {
    /// Retrieve the Swagger operation identifier that matches this request.
    ///
    /// Returns `None` if this request does not match any known operation on this API.
    fn parse_operation_id(req: &Request<B>) -> Option<&'static str>;
}

#[cfg(test)]
mod context_tests {
    use super::*;
    use bytes::Bytes;
    use http_body_util::Full;
    use hyper::Uri;
    use std::str::FromStr;

    struct TestParser1;

    impl RequestParser<Full<Bytes>> for TestParser1 {
        fn parse_operation_id(request: &Request<Full<Bytes>>) -> Option<&'static str> {
            match request.uri().path() {
                "/test/t11" => Some("t11"),
                "/test/t12" => Some("t12"),
                _ => None,
            }
        }
    }

    struct TestParser2;

    // these should be generalised to take in either empty of full bodies
    impl RequestParser<Full<Bytes>> for TestParser2 {
        fn parse_operation_id(request: &Request<Full<Bytes>>) -> Option<&'static str> {
            match request.uri().path() {
                "/test/t21" => Some("t21"),
                "/test/t22" => Some("t22"),
                _ => None,
            }
        }
    }

    #[test]
    fn test_macros() {
        let uri = Uri::from_str(&"https://www.rust-lang.org/test/t11").unwrap();
        let req1 = Request::get(uri).body(Full::default()).unwrap();

        let uri = Uri::from_str(&"https://www.rust-lang.org/test/t22").unwrap();
        let req2 = Request::get(uri).body(Full::default()).unwrap();

        let uri = Uri::from_str(&"https://www.rust-lang.org/test/t33").unwrap();
        let req3 = Request::get(uri).body(Full::default()).unwrap();

        request_parser_joiner!(JoinedReqParser, TestParser1, TestParser2);

        assert_eq!(JoinedReqParser::parse_operation_id(&req1), Some("t11"));
        assert_eq!(JoinedReqParser::parse_operation_id(&req2), Some("t22"));
        assert_eq!(JoinedReqParser::parse_operation_id(&req3), None);
    }
}
